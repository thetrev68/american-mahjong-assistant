[{"filePath":"C:\\Repos\\american-mahjong-assistant\\packages\\frontend\\src\\lib\\services\\__tests__\\analysis-engine.test.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Declaration or statement expected.","line":600,"column":0}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, vi } from 'vitest'\nimport { AnalysisEngine } from '../analysis-engine'\nimport { nmjlService } from '../nmjl-service'\nimport { PatternAnalysisEngine } from '../../../features/intelligence-panel/services/pattern-analysis-engine'\nimport { PatternRankingEngine } from '../../../features/intelligence-panel/services/pattern-ranking-engine'\nimport { TileRecommendationEngine } from '../../../features/intelligence-panel/services/tile-recommendation-engine'\nimport {\n  createTile,\n  createPatternSelection,\n  createAnalysisFacts,\n  createRankedPatternResults,\n  TilePresets,\n} from '../../../__tests__/factories'\n\n// Mock the service dependencies\nvi.mock('../nmjl-service')\nvi.mock('../../../features/intelligence-panel/services/pattern-analysis-engine')\nvi.mock('../../../features/intelligence-panel/services/pattern-ranking-engine') \nvi.mock('../../../features/intelligence-panel/services/tile-recommendation-engine')\n\ndescribe('Analysis Engine', () => {\n  beforeEach(() => {\n    vi.clearAllMocks()\n\n    // Clear AnalysisEngine cache between tests\n    AnalysisEngine.clearCache()\n\n    // Mock default responses from each engine\n    vi.mocked(nmjlService.getSelectionOptions).mockReturnValue([\n      createPatternSelection({ id: 1 }),\n      createPatternSelection({ id: 2 })\n    ])\n    \n    vi.mocked(PatternAnalysisEngine.analyzePatterns).mockReturnValue([\n      createAnalysisFacts({ patternId: 'pattern1', tilesMatched: 7 }),\n      createAnalysisFacts({ patternId: 'pattern2', tilesMatched: 5 })\n    ])\n    \n    vi.mocked(PatternRankingEngine.rankPatterns).mockReturnValue(\n      createRankedPatternResults({\n        patterns: [\n          createPatternSelection({ id: 1 }),\n          createPatternSelection({ id: 2 })\n        ]\n      })\n    )\n    \n    // Use implementation that works with correct parameter types\n    vi.mocked(TileRecommendationEngine.generateRecommendations).mockReturnValue({\n        tileActions: [\n          {\n            tileId: '1B',\n            primaryAction: 'keep',\n            confidence: 0.85,\n            reasoning: 'Critical for primary pattern',\n            priority: 9,\n            contextualActions: {\n              charleston: 'keep',\n              gameplay: 'keep',\n              exposition: 'keep'\n            },\n            patternsHelped: ['pattern1'],\n            multiPatternValue: 8,\n            dangers: []\n          },\n          {\n            tileId: '7C',\n            primaryAction: 'discard',\n            confidence: 0.7,\n            reasoning: 'Low strategic value',\n            priority: 3,\n            contextualActions: {\n              charleston: 'neutral',\n              gameplay: 'neutral',\n              exposition: 'never'\n            },\n            patternsHelped: [],\n            multiPatternValue: 1,\n            dangers: []\n          }\n        ],\n        keepTiles: [],\n        passTiles: [],\n        discardTiles: [],\n        optimalStrategy: {\n          primaryPattern: 'pattern1',\n          backupPattern: null,\n          pivotCondition: null,\n          expectedCompletion: 0.85\n        },\n        opponentAnalysis: [],\n        strategicAdvice: ['Focus on completing primary pattern', 'Consider joker substitution'],\n        emergencyActions: []\n      })\n    })\n  })\n\n  describe('Core Analysis Flow', () => {\n    it('should orchestrate 3-engine analysis successfully', async () => {\n      const tiles = TilePresets.mixedHand()\n      const patterns = [createPatternSelection({ id: 1 })]\n      \n      const result = await AnalysisEngine.analyzeHand(tiles, patterns)\n      \n      // Verify all engines were called\n      expect(PatternAnalysisEngine.analyzePatterns).toHaveBeenCalledWith(\n        tiles.map(t => t.id),\n        patterns.map(p => p.id),\n        expect.objectContaining({\n          jokersInHand: expect.any(Number),\n          wallTilesRemaining: expect.any(Number),\n          currentPhase: expect.any(String)\n        })\n      )\n      \n      expect(PatternRankingEngine.rankPatterns).toHaveBeenCalled()\n      expect(TileRecommendationEngine.generateRecommendations).toHaveBeenCalled()\n      \n      // Verify output structure\n      expect(result).toMatchObject({\n        overallScore: expect.any(Number),\n        recommendedPatterns: expect.any(Array),\n        bestPatterns: expect.any(Array),\n        tileRecommendations: expect.any(Array),\n        strategicAdvice: expect.any(Array),\n        threats: expect.any(Array),\n        lastUpdated: expect.any(Number),\n        analysisVersion: 'AV3-ThreeEngine',\n        engine1Facts: expect.any(Array)\n      })\n    })\n\n    it('should use provided patterns when given', async () => {\n      const tiles = TilePresets.mixedHand()\n      const patterns = [\n        createPatternSelection({ id: 1 }),\n        createPatternSelection({ id: 2 })\n      ]\n      \n      await AnalysisEngine.analyzeHand(tiles, patterns)\n      \n      expect(PatternAnalysisEngine.analyzePatterns).toHaveBeenCalledWith(\n        tiles.map(t => t.id),\n        expect.arrayContaining([\n          '2025-CONSECUTIVE_RUN-1',\n          '2025-CONSECUTIVE_RUN-2'\n        ]),\n        expect.objectContaining({\n          jokersInHand: expect.any(Number),\n          wallTilesRemaining: expect.any(Number),\n          currentPhase: expect.any(String)\n        })\n      )\n      \n      // Should not load all patterns when specific ones are provided\n      expect(nmjlService.getSelectionOptions).not.toHaveBeenCalled()\n    })\n\n    it('should load all patterns when none provided', async () => {\n      const tiles = TilePresets.mixedHand()\n      \n      await AnalysisEngine.analyzeHand(tiles, [])\n      \n      expect(nmjlService.getSelectionOptions).toHaveBeenCalled()\n      expect(PatternAnalysisEngine.analyzePatterns).toHaveBeenCalledWith(\n        tiles.map(t => t.id),\n        expect.arrayContaining([\n          '2025-CONSECUTIVE_RUN-1',\n          '2025-CONSECUTIVE_RUN-2'\n        ]), // From mocked service response with actual IDs\n        expect.objectContaining({\n          jokersInHand: expect.any(Number),\n          wallTilesRemaining: expect.any(Number),\n          currentPhase: expect.any(String)\n        })\n      )\n    })\n  })\n\n  describe('Game Context Handling', () => {\n    it('should create default game context when none provided', async () => {\n      const tiles = TilePresets.mixedHand()\n      const patterns = [createPatternSelection()]\n      \n      await AnalysisEngine.analyzeHand(tiles, patterns)\n      \n      expect(PatternAnalysisEngine.analyzePatterns).toHaveBeenCalledWith(\n        tiles.map(t => t.id),\n        patterns.map(p => p.id),\n        expect.objectContaining({\n          jokersInHand: expect.any(Number),\n          wallTilesRemaining: 80, // Default value\n          discardPile: [],\n          exposedTiles: {},\n          currentPhase: 'charleston'\n        })\n      )\n    })\n\n    it('should merge provided game context with defaults', async () => {\n      const tiles = TilePresets.mixedHand()\n      const patterns = [createPatternSelection()]\n      const gameContext = {\n        wallTilesRemaining: 50,\n        currentPhase: 'gameplay',\n        discardPile: ['1B', '2C']\n      }\n      \n      await AnalysisEngine.analyzeHand(tiles, patterns, gameContext)\n      \n      expect(PatternAnalysisEngine.analyzePatterns).toHaveBeenCalledWith(\n        tiles.map(t => t.id),\n        patterns.map(p => p.id),\n        expect.objectContaining({\n          wallTilesRemaining: 50,\n          currentPhase: 'gameplay',\n          discardPile: ['1B', '2C'],\n          exposedTiles: {}, // Still uses default\n          jokersInHand: expect.any(Number)\n        })\n      )\n    })\n\n    it('should correctly count jokers in hand', async () => {\n      const tiles = [\n        createTile({ id: '1B' }),\n        createTile({ id: 'joker', isJoker: true }),\n        createTile({ id: 'joker2', suit: 'jokers' }),\n        createTile({ id: '2C' })\n      ]\n      const patterns = [createPatternSelection()]\n      \n      await AnalysisEngine.analyzeHand(tiles, patterns)\n      \n      expect(PatternAnalysisEngine.analyzePatterns).toHaveBeenCalledWith(\n        tiles.map(t => t.id),\n        patterns.map(p => p.id),\n        expect.objectContaining({\n          jokersInHand: 2 // Should count both joker tiles\n        })\n      )\n    })\n  })\n\n  describe('Result Conversion', () => {\n    it('should convert pattern rankings to recommended patterns format', async () => {\n      const mockPatternRankings = createRankedPatternResults({\n        patterns: [createPatternSelection({ id: 1, difficulty: 'easy', points: 25 })]\n      })\n      \n      vi.mocked(PatternRankingEngine.rankPatterns).mockReturnValue(mockPatternRankings)\n      \n      const result = await AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [])\n      \n      expect(result.recommendedPatterns.length).toBeGreaterThan(0) // Based on actual pattern rankings\n      expect(result.recommendedPatterns[0]).toMatchObject({\n        pattern: expect.any(Object),\n        confidence: expect.any(Number),\n        completionPercentage: expect.any(Number),\n        reasoning: expect.any(String),\n        difficulty: expect.any(String),\n        isPrimary: expect.any(Boolean),\n        scoreBreakdown: expect.objectContaining({\n          currentTileScore: expect.any(Number),\n          availabilityScore: expect.any(Number),\n          jokerScore: expect.any(Number),\n          priorityScore: expect.any(Number)\n        })\n      })\n    })\n\n    it('should convert tile actions to tile recommendations format', async () => {\n      const result = await AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [])\n      \n      expect(result.tileRecommendations).toHaveLength(2) // Based on mock response\n      expect(result.tileRecommendations[0]).toMatchObject({\n        tileId: '1B',\n        action: 'keep',\n        confidence: 0.85,\n        reasoning: 'Critical for primary pattern',\n        priority: 9\n      })\n      expect(result.tileRecommendations[1]).toMatchObject({\n        tileId: '7C',\n        action: 'discard',\n        confidence: 0.7,\n        reasoning: 'Low strategic value',\n        priority: 3\n      })\n    })\n\n    it('should normalize tile actions correctly', async () => {\n      vi.mocked(TileRecommendationEngine.generateRecommendations).mockReturnValue({\n        tileActions: [\n          {\n            tileId: '1B',\n            primaryAction: 'keep',\n            confidence: 0.8,\n            reasoning: 'test',\n            priority: 5,\n            contextualActions: { charleston: 'keep', gameplay: 'keep', exposition: 'keep' },\n            patternsHelped: ['pattern1'],\n            multiPatternValue: 5,\n            dangers: []\n          },\n          {\n            tileId: '2C',\n            primaryAction: 'pass',\n            confidence: 0.6,\n            reasoning: 'test',\n            priority: 3,\n            contextualActions: { charleston: 'neutral', gameplay: 'keep', exposition: 'expose' },\n            patternsHelped: [],\n            multiPatternValue: 2,\n            dangers: []\n          },\n          {\n            tileId: '3D',\n            primaryAction: 'discard',\n            confidence: 0.4,\n            reasoning: 'test',\n            priority: 1,\n            contextualActions: { charleston: 'neutral', gameplay: 'neutral', exposition: 'never' },\n            patternsHelped: [],\n            multiPatternValue: 1,\n            dangers: []\n          }\n        ],\n        keepTiles: [],\n        passTiles: [],\n        discardTiles: [],\n        optimalStrategy: {\n          primaryPattern: 'pattern1',\n          backupPattern: null,\n          pivotCondition: null,\n          expectedCompletion: 0.7\n        },\n        opponentAnalysis: [],\n        strategicAdvice: [],\n        emergencyActions: []\n      })\n      \n      const result = await AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [])\n      \n      expect(result.tileRecommendations[0].action).toBe('keep')\n      expect(result.tileRecommendations[1].action).toBe('pass')\n      expect(result.tileRecommendations[2].action).toBe('discard')\n    })\n  })\n\n  describe('Caching System', () => {\n    it('should cache Engine 1 results for identical requests', async () => {\n      const tiles = TilePresets.mixedHand()\n      const patterns = [createPatternSelection({ id: 1 })]\n      \n      // First analysis\n      await AnalysisEngine.analyzeHand(tiles, patterns)\n      expect(PatternAnalysisEngine.analyzePatterns).toHaveBeenCalledTimes(1)\n      \n      // Second identical analysis - should use cache\n      await AnalysisEngine.analyzeHand(tiles, patterns)\n      expect(PatternAnalysisEngine.analyzePatterns).toHaveBeenCalledTimes(1) // Still only called once\n    })\n\n    it('should bypass cache for different hands', async () => {\n      const tiles1 = [createTile({ id: '1B' })]\n      const tiles2 = [createTile({ id: '2B' })]\n      const patterns = [createPatternSelection()]\n      \n      await AnalysisEngine.analyzeHand(tiles1, patterns)\n      await AnalysisEngine.analyzeHand(tiles2, patterns)\n      \n      expect(PatternAnalysisEngine.analyzePatterns).toHaveBeenCalledTimes(2)\n    })\n\n    it('should bypass cache for different patterns', async () => {\n      const tiles = TilePresets.mixedHand()\n      const patterns1 = [createPatternSelection({ id: 1 })]\n      const patterns2 = [createPatternSelection({ id: 2 })]\n      \n      await AnalysisEngine.analyzeHand(tiles, patterns1)\n      await AnalysisEngine.analyzeHand(tiles, patterns2)\n      \n      expect(PatternAnalysisEngine.analyzePatterns).toHaveBeenCalledTimes(2)\n    })\n\n    it('should bypass cache for different game contexts', async () => {\n      const tiles = TilePresets.mixedHand()\n      const patterns = [createPatternSelection()]\n      \n      await AnalysisEngine.analyzeHand(tiles, patterns, { wallTilesRemaining: 50 })\n      await AnalysisEngine.analyzeHand(tiles, patterns, { wallTilesRemaining: 30 })\n      \n      expect(PatternAnalysisEngine.analyzePatterns).toHaveBeenCalledTimes(2)\n    })\n\n    it('should clear cache for hand changes', () => {\n      const oldTiles = ['1B', '2B', '3B']\n      const newTiles = ['1B', '2B', '4B'] // Changed one tile\n      \n      // This should clear cache entries for the old hand\n      expect(() => AnalysisEngine.clearCacheForHandChange(oldTiles, newTiles)).not.toThrow()\n    })\n\n    it('should not clear cache when hand unchanged', () => {\n      const tiles = ['1B', '2B', '3B']\n      \n      // This should not clear cache as hand is identical\n      expect(() => AnalysisEngine.clearCacheForHandChange(tiles, tiles)).not.toThrow()\n    })\n\n    it('should provide cache statistics', () => {\n      const stats = AnalysisEngine.getCacheStats()\n      \n      expect(stats).toMatchObject({\n        size: expect.any(Number)\n      })\n    })\n  })\n\n  describe('Pattern Analysis Details', () => {\n    it('should calculate completion percentage from current tile score', async () => {\n      const mockRankings = createRankedPatternResults({\n        patterns: [createPatternSelection({ id: 1 })]\n      })\n      \n      // Mock a ranking with specific current tile score\n      mockRankings.topRecommendations[0].components.currentTileScore = 20 // 50% completion\n      \n      vi.mocked(PatternRankingEngine.rankPatterns).mockReturnValue(mockRankings)\n      \n      const result = await AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [])\n      \n      expect(result.recommendedPatterns[0].completionPercentage).toBe(50) // 20/40 * 100\n      expect(result.bestPatterns[0].completionPercentage).toBe(50)\n    })\n\n    it('should extract matching groups from analysis facts', async () => {\n      const mockFacts = [createAnalysisFacts({\n        patternId: 'test',\n        tileContributions: [\n          { tileId: '1B', positionsInPattern: [0], isRequired: true, isCritical: true, canBeReplaced: false },\n          { tileId: '2B', positionsInPattern: [1], isRequired: true, isCritical: false, canBeReplaced: true }\n        ]\n      })]\n      \n      vi.mocked(PatternAnalysisEngine.analyzePatterns).mockReturnValue(mockFacts)\n      \n      const result = await AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [createPatternSelection({ id: 1 })])\n      \n      // Should extract matching groups from tile contributions\n      expect(result.recommendedPatterns[0].analysis?.currentTiles.matchingGroups).toBeDefined()\n    })\n\n    it('should calculate strategic value from pattern ranking components', async () => {\n      const result = await AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [])\n      \n      expect(result.recommendedPatterns[0].analysis?.strategicValue).toMatchObject({\n        tilePriorities: expect.any(Object),\n        groupPriorities: expect.any(Object),\n        overallPriority: expect.any(Number),\n        reasoning: expect.any(Array)\n      })\n    })\n  })\n\n  describe('Error Handling', () => {\n\n    it('should handle Pattern Analysis Engine errors', async () => {\n      vi.mocked(nmjlService.getSelectionOptions).mockReset().mockReturnValue([createPatternSelection()])\n      vi.mocked(PatternAnalysisEngine.analyzePatterns).mockReset().mockRejectedValue(new Error('Engine 1 failed'))\n      \n      await expect(AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [])).rejects.toThrow('Analysis engine failure: Engine 1 failed')\n    })\n\n    it.skip('should handle Pattern Ranking Engine errors', async () => {\n      vi.mocked(nmjlService.getSelectionOptions).mockReset().mockReturnValue([createPatternSelection()])\n      vi.mocked(PatternAnalysisEngine.analyzePatterns).mockReset().mockReturnValue([createAnalysisFacts()])\n      vi.mocked(PatternRankingEngine.rankPatterns).mockReset().mockRejectedValue(new Error('Engine 2 failed'))\n      \n      await expect(AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [])).rejects.toThrow('Analysis engine failure: Engine 2 failed')\n    })\n\n    it.skip('should handle Tile Recommendation Engine errors', async () => {\n      vi.mocked(nmjlService.getSelectionOptions).mockReset().mockReturnValue([createPatternSelection()])\n      vi.mocked(PatternAnalysisEngine.analyzePatterns).mockReset().mockReturnValue([createAnalysisFacts()])\n      vi.mocked(PatternRankingEngine.rankPatterns).mockReset().mockReturnValue(createRankedPatternResults())\n      vi.mocked(TileRecommendationEngine.generateRecommendations).mockReset().mockRejectedValue(new Error('Engine 3 failed'))\n      \n      await expect(AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [])).rejects.toThrow('Analysis engine failure: Engine 3 failed')\n    })\n\n    it.skip('should handle NMJL service errors gracefully', async () => {\n      vi.mocked(nmjlService.getSelectionOptions).mockReset().mockRejectedValue(new Error('Pattern loading failed'))\n      \n      await expect(AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [])).rejects.toThrow('Analysis engine failure: Pattern loading failed')\n    })\n\n    it('should handle non-Error exceptions', async () => {\n      vi.mocked(nmjlService.getSelectionOptions).mockReset().mockReturnValue([createPatternSelection()])\n      vi.mocked(PatternAnalysisEngine.analyzePatterns).mockReset().mockRejectedValue('String error')\n      \n      await expect(AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [])).rejects.toThrow('Analysis engine failure: Unknown error')\n    })\n  })\n\n  describe('Performance and Edge Cases', () => {\n    it('should handle empty tile arrays', async () => {\n      const result = await AnalysisEngine.analyzeHand([], [createPatternSelection()])\n      \n      expect(result).toBeDefined()\n      expect(result.tileRecommendations).toBeDefined()\n      expect(result.recommendedPatterns).toBeDefined()\n    })\n\n    it('should handle empty pattern arrays', async () => {\n      const result = await AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [])\n      \n      expect(result).toBeDefined()\n      expect(nmjlService.getSelectionOptions).toHaveBeenCalled() // Should load patterns\n    })\n\n    it('should handle large numbers of patterns efficiently', async () => {\n      const manyPatterns = Array.from({ length: 50 }, (_, i) =>\n        createPatternSelection({ id: i + 1 })\n      )\n      \n      const startTime = performance.now()\n      const result = await AnalysisEngine.analyzeHand(TilePresets.mixedHand(), manyPatterns)\n      const duration = performance.now() - startTime\n      \n      expect(result).toBeDefined()\n      expect(duration).toBeLessThan(5000) // Should complete within 5 seconds\n    })\n\n    it('should handle patterns with missing data gracefully', async () => {\n      const mockRankings = createRankedPatternResults({\n        patterns: [createPatternSelection({ id: 1 })]\n      })\n      \n      mockRankings.topRecommendations[0].patternId = 'nonexistent-pattern'\n      vi.mocked(PatternRankingEngine.rankPatterns).mockReturnValue(mockRankings)\n      \n      const result = await AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [])\n      \n      expect(result.recommendedPatterns[0].pattern).toMatchObject({\n        id: 'nonexistent-pattern',\n        displayName: 'nonexistent-pattern' // Fallback values\n      })\n    })\n  })\n\n  describe('Integration Points', () => {\n    it('should pass Engine 1 facts to Engine 3', async () => {\n      const mockFacts = [createAnalysisFacts({ patternId: 'test' })]\n      vi.mocked(PatternAnalysisEngine.analyzePatterns).mockReturnValue(mockFacts)\n      \n      await AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [])\n      \n      expect(TileRecommendationEngine.generateRecommendations).toHaveBeenCalledWith(\n        expect.any(Array), // tileIds\n        expect.any(Object), // patternRankings\n        expect.any(Object), // context\n        mockFacts // Engine 1 facts should be passed to Engine 3\n      )\n    })\n\n    it('should maintain engine1Facts in result for UI access', async () => {\n      const result = await AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [])\n      \n      expect(result.engine1Facts).toBeDefined()\n      expect(result.engine1Facts).toHaveLength(2) // Based on default mock\n    })\n\n    it('should sort recommendations by AI total score (enhanced precision)', async () => {\n      const mockRankings = createRankedPatternResults({\n        patterns: [\n          createPatternSelection({ id: 1 }),\n          createPatternSelection({ id: 2 })\n        ]\n      })\n\n      // Set different AI total scores (pattern with higher AI score should come first)\n      mockRankings.topRecommendations[0].totalScore = 60 // Lower AI score\n      mockRankings.topRecommendations[0].components.currentTileScore = 30 // Higher completion\n      mockRankings.topRecommendations[1].totalScore = 85 // Higher AI score\n      mockRankings.topRecommendations[1].components.currentTileScore = 10 // Lower completion\n\n      vi.mocked(PatternRankingEngine.rankPatterns).mockReturnValue(mockRankings)\n\n      const result = await AnalysisEngine.analyzeHand(TilePresets.mixedHand(), [])\n\n      // Should be sorted by AI total score (highest first), not just completion percentage\n      expect(result.recommendedPatterns[0].totalScore).toBe(85) // Higher AI score comes first\n      expect(result.recommendedPatterns[1].totalScore).toBe(60) // Lower AI score comes second\n      expect(result.recommendedPatterns[0].completionPercentage).toBe(25) // Lower completion but higher AI score\n      expect(result.recommendedPatterns[1].completionPercentage).toBe(75) // Higher completion but lower AI score\n    })\n  })\n})\n\n// Ensure file is treated as a module for parsers\nexport {}\n","usedDeprecatedRules":[]}]
